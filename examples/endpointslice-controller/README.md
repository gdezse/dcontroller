# EndpointSlice operator

The EndpointSlice operator is a simple Kubernetes controller that demonstrates the use Δ-controller
to manage the endpoint pool for a service. The operator demonstrates how to use Δ-controller from
Go code, where instead of writing the objects emitted by a controller back into the Kubernetes API
server, which is the default use case of Δ-controller and can be fully implemented in a declarative
style, the output objects need to be processes from Go.

## Description

Certain use cases cannot be fully implemented in a purely declarative style, e.g., because a
Kubernetes operator needs to manipulate an imperative API. Such is the case, for instance, when the
task is to implement service-discovery operator that programs an underlying system with the set of
endpoints that expose a certain service (e.g., the underlying system can be a proxy and the use
case may be a simple service mesh operator). Even in such cases Δ-controller can come in handy, by
allowing the most difficult part of the operator, the service-discovery pipeline, in a declarative
form, letting us to concentrate on having to write the reconciliation logic that will update the
imperative API based on the endpoints discovered by the declarative controller.

This example demonstrates the use of Δ-controller for such cases. The example comprises two parts:
a custom **endointslice operator** that is written in Go and using the Δ-controller API, and a
declarative **endpointslice controller pipeline** that automates the difficult part: generating the
up-to-date list of endpoints for a Kubernetes Service based on the Kubernetes resources obtained
from the API server.

### The endointslice operator

The operator, written in Go, does not differ too much from a standard [Kubernetes
operator](https://book.kubebuilder.io/), just with the common packages taken from Δ-controller
instead of the usual [Kubernetes controller
runtime](https://pkg.go.dev/sigs.k8s.io/controller-runtime).

1. Define the usual boilerplate for importing packages, defining some constants, parsing
   the command line arguments, and setting a logger.
   
2. Create a Δ-controller manager:

   ```go
   mgr, err := dmanager.New(ctrl.GetConfigOrDie(), dmanager.Options{
       Options: ctrl.Options{Scheme: scheme},
   })
   if err != nil { ... }
   ```

3. Load the declarative operator pipeline from a file `specFile` (see later):

   ```go
   if _, err := doperator.NewFromFile("endpointslice-operator", mgr, specFile, opts); err != nil {
      ...
   }
   ```

4. Define the controller that will process the events generated by the operator:

   ```go
   if _, err := NewEndpointSliceController(mgr, logger); err != nil { ... }
   ```

5. Start the manager (this will readily start our controllers):

   ```go
   if err := mgr.Start(ctx); err != nil { ... }
   ```

The logic is pretty much the same as with a common Kubernetes operator. The endpointslice
controller itself likewise follows the usual Kubernetes operator pattern: by define an
`endpointSliceController` struct that will represent our controller, write a constructor, and
implement the `func Reconcile(context.Context, dreconciler.Request) (reconcile.Result, error)`
function on the struct that will effectively process the events generated by the declarative
controller.

The constructor will be called `NewEndpointSliceController`:

1. Construct the `endpointSliceController` struct:

   ```go
   r := &endpointSliceController{
      Client: mgr.GetClient(),
      log:    log.WithName("endpointSlice-ctrl"),
   }
   ```

2. Define the controller:

   ```go
   on := true
   c, err := controller.NewTyped("endpointslice-controller", mgr, controller.TypedOptions[dreconciler.Request]{
      SkipNameValidation: &on,
      Reconciler:         r,
   })
   if err != nil { ... }
   ```

3. Create a source for the `EndpointSliceView` (this will be generated by the declarative part):

   ```go
   src, err := dreconciler.NewSource(mgr, opv1a1.Source{
      Resource: opv1a1.Resource{
         Kind: "EndpointSliceView",
      },
   }).GetSource()
   if err != nil { ... }
   ```

4. And finally set up a watch that will bind our controller to the above source so that every time
   there is an update on the `EndpointSliceView` our `Reconcile(...)` function will be called with
   the event to process it.

   ```go
   if err := c.Watch(src); err != nil { ... }
   ```

And finally the most important part, the `Reconcile(...)` function. Normally, this would be the
function that implements the business logic of our operator, say, by controlling a proxy with the
endpoints discovered by our operator. Here for simplicity we will just log the events and return a
successful reconcile result.

```go
func (r *endpointSliceController) Reconcile(ctx context.Context, req dreconciler.Request) (reconcile.Result, error) {
   r.log.Info("Reconciling", "request", req.String())

   switch req.EventType {
       case cache.Added, cache.Updated, cache.Upserted:
    
        r.log.Info("Add/update EndpointSliceView object", "name", req.Name, "namespace", req.Namespace)
    
       // handle upsert event
    
       case cache.Deleted:
          r.log.Info("Delete EndpointSliceView object", "name", req.Name, "namespace", req.Namespace)
    
       // handle delete event
    
       default:
          r.log.Info("Unhandled event", "name", req.Name, "namespace", req.Namespace, "type", req.EventType)
   }

   return reconcile.Result{}, nil
}
```

### The declarative controller

TODO

## Testing

Deploy the custom `endointslice-operator`  Δ-controller is up and running. Then, load the ConfigDeployment custom resource definition:

```console
cd <project-root>
go run examples/endpointslice-controller/main.go -zap-log-level info -disable-endpoint-pooling
```

Deploy a sample service:

``` console
kubectl create deployment pause-demo --image=registry.k8s.io/pause:3.9 --replicas=2
kubectl expose deployment pause-demo
```

TODO

## Cleanup

Remove all resources we have created:

```console
kubectl delete deployments pause-demo
kubectl delete services pause-demo
```

## License

Copyright 2025 by its authors. Some rights reserved. See [AUTHORS](AUTHORS).

Apache License - see [LICENSE](LICENSE) for full text.

